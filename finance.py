# -*- coding: utf-8 -*-
"""finance.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YqJcokuVvaYrhyPtXFAa-lrLgyt4dJMN
"""

import streamlit as st
import pandas as pd
import numpy as np
import streamlit as st
from streamlit_option_menu import option_menu
import plotly.express as px
import yfinance as yf
import random

def render_styled_table(df):
    st.markdown("""
        <style>
            .styled-table {
                border-collapse: collapse;
                margin: 25px 0;
                font-size: 0.9em;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                width: 100%;
                border: 1px solid #ddd;
            }
            .styled-table th, .styled-table td {
                padding: 12px 15px;
                border: 1px solid #ddd;
                text-align: center;
            }
            .styled-table thead {
                background-color: #009879;
                color: #ffffff;
            }
            .styled-table tbody tr:nth-child(even) {
                background-color: #f3f3f3;
            }
        </style>
    """, unsafe_allow_html=True)

    html_table = df.to_html(index=False, classes="styled-table")
    st.markdown(html_table, unsafe_allow_html=True)

class FinanceTab:

    def __init__(self):
        pass

    def Credit_Card_Fraud_Detection(self):
        tab = st.selectbox("Select Module", ["üö® Credit Card Fraud Detection", "üè¶ Loan Approval Prediction"])

        # ----- Fraud Detection Tab -----
        if tab == "üö® Credit Card Fraud Detection":
            st.markdown(" ", unsafe_allow_html=True)
            st.markdown(" ", unsafe_allow_html=True)
            st.markdown(
            """
            <div style='
                background-color: #EEEEEE;
                padding: 10px 20px;
                border-radius: 10px;
                border: 1px solid #ccc;
                margin-bottom: 30px;
                text-align: center;
            '>
                <h4 style='color: #1a1a1a;'> üö® Real-time Transaction Check </h4>
            """,
            unsafe_allow_html=True
                    )
            #st.header("üö® Real-time Transaction Check")
            st.markdown("---", unsafe_allow_html=True)
            st.markdown("Simulate a credit card transaction to check for fraud.")

            col1, col2, col3 = st.columns(3)

            with col1:
                amount = st.slider("Transaction Amount ($)", 1, 5000, 200)

            with col2:
                time_gap = st.slider("Time Since Last Transaction (sec)", 0, 600, 45)

            with col3:
                location_change = st.selectbox("Location Changed?", ["No", "Yes"])

            if st.button("Analyze Transaction"):
                # Simple fraud scoring logic
                score = amount * 0.01 + time_gap * 0.02
                if location_change == "Yes":
                    score += 15

                result = "Fraudulent" if score > 50 else "Legit"
                st.metric("Risk Score", round(score, 2))
                st.success(f"‚úÖ Transaction is {result}" if result == "Legit" else f"üö® Alert: {result} Transaction")

        # ----- Loan Approval Tab -----
        elif tab == "üè¶ Loan Approval Prediction":
            st.markdown(" ", unsafe_allow_html=True)
            st.markdown(" ", unsafe_allow_html=True)
            st.markdown(
            """
            <div style='
                background-color: #EEEEEE;
                padding: 10px 20px;
                border-radius: 10px;
                border: 1px solid #ccc;
                margin-bottom: 30px;
                text-align: center;
            '>
                <h4 style='color: #1a1a1a;'> üè¶ Apply for a Loan </h4>
            """,
            unsafe_allow_html=True
                    )
            #st.header("üè¶ Apply for a Loan")
            st.markdown("---", unsafe_allow_html=True)
            st.markdown("Automate loan approvals based on applicant profile.")

            with st.form("loan_form"):
                col1, col2, col3 = st.columns(3)

                with col1:
                    age = st.number_input("Age", 18, 75, 30)
                    income = st.number_input("Monthly Income ($)", 1000, 20000, 5000)

                with col2:
                    credit_score = st.slider("Credit Score", 300, 900, 650)
                    loan_amount = st.number_input("Loan Amount Requested ($)", 500, 100000, 15000)

                with col3:
                    employment = st.selectbox("Employment Type", ["Salaried", "Self-Employed", "Unemployed"])

                submit_loan = st.form_submit_button("Predict Loan Decision")

            if submit_loan:
                # Simulated rule-based approval
                approved = credit_score > 600 and income > 3000 and loan_amount < (income * 10)
                confidence = random.uniform(70, 95) if approved else random.uniform(40, 65)
                st.metric("Confidence Score", f"{round(confidence, 2)}%")
                if approved:
                    st.success("‚úÖ Loan Approved")
                else:
                    st.error("‚ùå Loan Denied")

    def Risk_Scoring(self):
        st.markdown(" ", unsafe_allow_html=True)
        st.markdown(
        """
        <div style='
            background-color: #EEEEEE;
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid #ccc;
            margin-bottom: 30px;
            text-align: center;
        '>
            <h4 style='color: #1a1a1a;'> Use AI to predict a person's financial risk score and understand what factors influenced the decision </h4>
        """,
        unsafe_allow_html=True
                )

        # --- Input Form ---
        st.markdown(
        """
        <div style='
            background-color: #EEEEEE;
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid #ccc;
            margin-bottom: 30px;
            text-align: left;
        '>
            <h4 style='color: #1a1a1a;'> üßæ Applicant Details </h4>
        """,
        unsafe_allow_html=True
                )

        #st.markdown("### üßæ Applicant Details")
        with st.form("risk_form"):
            col1, col2, col3 = st.columns(3)

            with col1:
                age = st.slider("Age", 18, 75, 35)
                income = st.slider("Monthly Income ($)", 1000, 20000, 5000)

            with col2:
                credit_history = st.slider("Credit History (Years)", 0, 20, 5)
                current_debt = st.slider("Current Debt ($)", 0, 50000, 10000)

            with col3:
                defaults = st.selectbox("Past Loan Defaults", [0, 1, 2, 3])
                employment = st.selectbox("Employment Type", ["Salaried", "Self-Employed", "Unemployed"])
                marital = st.selectbox("Marital Status", ["Single", "Married", "Divorced"])

            submitted = st.form_submit_button("Predict Risk Score")

        # --- Simulated Risk Prediction Function ---
        def simulate_risk_score(age, income, credit_history, current_debt, defaults, employment, marital):
            score = 100
            score -= age * 0.2
            score += np.log(income + 1) * 2
            score += credit_history * 1.5
            score -= current_debt / 1000
            score -= defaults * 5

            if employment == "Unemployed":
                score -= 15
            elif employment == "Self-Employed":
                score -= 5

            if marital == "Divorced":
                score -= 5

            return max(0, min(100, round(score, 1)))

        # --- Feature Contribution Explanation (Simulated) ---
        def explain_contributions():
            return pd.DataFrame({
                "Feature": [
                    "Credit History", "Income", "Current Debt", "Loan Defaults",
                    "Age", "Employment Type", "Marital Status"
                ],
                "Impact on Score": [
                    credit_history * 1.5,
                    np.log(income + 1) * 2,
                    -current_debt / 1000,
                    -defaults * 5,
                    -age * 0.2,
                    -15 if employment == "Unemployed" else (-5 if employment == "Self-Employed" else 0),
                    -5 if marital == "Divorced" else 0
                ]
            }).sort_values(by="Impact on Score", ascending=False)

        # --- Output Section ---
        if submitted:
            risk_score = simulate_risk_score(age, income, credit_history, current_debt, defaults, employment, marital)

            if risk_score >= 70:
                risk_level = "üü¢ Low Risk"
            elif risk_score >= 40:
                risk_level = "üü† Medium Risk"
            else:
                risk_level = "üî¥ High Risk"

            st.metric(label="Predicted Risk Score", value=risk_score)
            st.success(f"Risk Category: {risk_level}")

            st.markdown("### üß† Explainable AI - Feature Contributions")
            exp_df = explain_contributions()
            fig = px.bar(exp_df, x="Impact on Score", y="Feature", orientation="h",
                        color="Impact on Score", color_continuous_scale="RdYlGn")
            st.plotly_chart(fig, use_container_width=True)
            st.markdown("---", unsafe_allow_html=True)

    def Portfolio_Optimization(self):
        st.markdown("---", unsafe_allow_html=True)
        st.markdown(
        """
        <div style='
            background-color: #EEEEEE;
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid #ccc;
            margin-bottom: 30px;
            text-align: center;
        '>
            <h4 style='color: #1a1a1a;'> Simulate a reinforcement learning-based investment strategy to dynamically allocate portfolio weights and optimize returns. </h4>
        """,
        unsafe_allow_html=True
                )

        # --- User Inputs ---
        st.sidebar.header("üí∞ Portfolio Settings")
        initial_capital = st.sidebar.number_input("Initial Capital ($)", 1000, 100000, 10000)
        risk_level = st.sidebar.selectbox("Risk Tolerance", ["Low", "Medium", "High"])
        invest_days = st.sidebar.slider("Investment Horizon (Days)", 30, 180, 90)
        tickers = st.sidebar.multiselect(
            "Select Asset Tickers (Max 5)",
            ["AAPL", "MSFT", "GOOG", "TSLA", "AMZN", "META", "BND", "GLD"],
            default=["AAPL", "TSLA", "BND"]
        )

        if len(tickers) < 2:
            st.warning("Please select at least 2 assets to simulate the portfolio.")
            st.stop()

        # --- Fetch Historical Data ---
        end_date = pd.Timestamp.today()
        start_date = end_date - pd.Timedelta(days=invest_days*2)  # buffer for lookback

        #@st.cache_data
        def load_data(tickers, start, end):
            data = yf.download(tickers, start=start, end=end)
            
            if data.empty:
                st.error("‚ö†Ô∏è Failed to load stock data. Check tickers and internet connection.")

            # If multiple tickers, extract only Adjusted Close prices correctly
            if len(tickers) > 1:
                try:
                    data = data['Adj Close']
                except KeyError:
                    st.error("‚ö†Ô∏è 'Adj Close' not found in the downloaded data.")
                    render_styled_table(data.head())
            else:
                # For single ticker, 'Adj Close' is a series
                data = data['Adj Close'].to_frame(name=tickers[0])
            
            return data.dropna()

        price_df = load_data(tickers, start_date, end_date)
        returns = price_df.pct_change().dropna()

        # --- Simulated RL Strategy (momentum + volatility rebalancing) ---
        def simulate_rl_portfolio(returns, capital, risk_level):
            weights_history = []
            value_history = [capital]
            days = len(returns)
            tickers = returns.columns.tolist()
            weights = np.ones(len(tickers)) / len(tickers)

            for i in range(days):
                daily_ret = returns.iloc[i]
                portfolio_ret = np.dot(weights, daily_ret)
                capital *= (1 + portfolio_ret)
                value_history.append(capital)

                # Simulate rebalancing logic every 10 days
                if i % 10 == 0 and i > 0:
                    vol = returns.iloc[max(0, i - 10):i].std()
                    mom = returns.iloc[max(0, i - 10):i].mean()
                    score = mom / vol

                    if risk_level == "Low":
                        score = 1 / vol
                    elif risk_level == "High":
                        score = mom * vol

                    new_weights = score / score.sum()
                    weights = new_weights.values
                    weights_history.append(weights)

            return value_history, weights, weights_history

        # --- Run Simulation ---
        portfolio_values, final_weights, weights_history = simulate_rl_portfolio(returns, initial_capital, risk_level)

        # --- Output Charts ---
        st.subheader("üìà Portfolio Value Over Time")

        # --- Check if price_df is valid ---
        if price_df.empty:
            st.error("‚ùå No data was found for the selected tickers and time range. Please adjust your selections.")
            st.stop()

        # --- Generate dates list for plotting ---
        # returns has one fewer row than portfolio_values (due to initial capital)
        dates = price_df.index.tolist()
        dates = [dates[0] - pd.Timedelta(days=1)] + dates  # prepend day-1 for initial capital

        # Ensure equal lengths
        if len(dates) != len(portfolio_values):
            min_len = min(len(dates), len(portfolio_values))
            dates = dates[:min_len]
            portfolio_values = portfolio_values[:min_len]

        # --- Final Portfolio Value DataFrame ---
        value_df = pd.DataFrame({
            "Date": dates,
            "Portfolio Value": portfolio_values
        })

        st.line_chart(value_df.set_index("Date"))

        # Use only tickers that were used in returns (i.e., data existed for them)
        valid_tickers = returns.columns.tolist()

        # Create pie chart from final weights
        if len(valid_tickers) != len(final_weights):
            st.error("‚ö†Ô∏è Mismatch between final weights and valid tickers. Please review input data.")
        else:
            st.subheader("üìä Final Portfolio Allocation")
            pie_df = pd.DataFrame({
                "Asset": valid_tickers,
                "Weight": final_weights
            })

            fig = px.pie(pie_df, names='Asset', values='Weight', title='Final Weights')
            st.plotly_chart(fig)

            # --- Summary ---
            total_return = (portfolio_values[-1] - portfolio_values[0]) / portfolio_values[0] * 100
            st.metric("üíµ Total Return", f"{total_return:.2f}%")